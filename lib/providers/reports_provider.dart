import 'dart:async';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:firebase_storage/firebase_storage.dart';
import '../models/user_report.dart';
import '../services/firebase_service.dart';

class ReportsProvider with ChangeNotifier {
  List<UserReport> _reports = [];
  List<UserReport> _myReports = [];
  bool _isLoading = false;
  String? _errorMessage;
  
  StreamSubscription? _reportsSubscription;
  
  // Getters
  List<UserReport> get reports => _reports;
  List<UserReport> get myReports => _myReports;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  // Initialize provider
  void initialize({String? userId}) {
    _setupReportsStream();
    if (userId != null) {
      _setupMyReportsStream(userId);
    }
  }

  void _setupReportsStream() {
    _reportsSubscription = FirebaseService.getUserReportsStream().listen(
      (reportsList) {
        _reports = reportsList;
        notifyListeners();
      },
      onError: (error) {
        _setError('Failed to load reports: $error');
      },
    );
  }

  void _setupMyReportsStream(String userId) {
    FirebaseService.getUserReportsStream().listen(
      (reportsList) {
        _myReports = reportsList.where((report) => report.userId == userId).toList();
        notifyListeners();
      },
      onError: (error) {
        _setError('Failed to load my reports: $error');
      },
    );
  }

  // Submit new report
  Future<bool> submitReport({
    required String userId,
    required String userName,
    required String pondId,
    required String title,
    required String description,
    required ReportType type,
    required Priority priority,
    List<File>? images,
  }) async {
    _setLoading(true);
    try {
      List<String> imageUrls = [];
      
      // Upload images if provided
      if (images != null && images.isNotEmpty) {
        imageUrls = await _uploadImages(images);
      }

      final report = UserReport(
        id: '', // Will be generated by Firestore
        userId: userId,
        userName: userName,
        pondId: pondId,
        title: title,
        description: description,
        type: type,
        priority: priority,
        imageUrls: imageUrls,
        reportTime: DateTime.now(),
        status: ReportStatus.pending,
      );

      final reportId = await FirebaseService.submitUserReport(report);
      
      if (reportId != null) {
        _setError(null);
        return true;
      } else {
        _setError('Failed to submit report');
        return false;
      }
    } catch (e) {
      _setError('Error submitting report: $e');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  // Upload images to Firebase Storage
  Future<List<String>> _uploadImages(List<File> images) async {
    List<String> urls = [];
    
    for (int i = 0; i < images.length; i++) {
      try {
        final storageRef = FirebaseStorage.instance
            .ref()
            .child('reports')
            .child('${DateTime.now().millisecondsSinceEpoch}_$i.jpg');
            
        final uploadTask = storageRef.putFile(images[i]);
        final snapshot = await uploadTask;
        final url = await snapshot.ref.getDownloadURL();
        urls.add(url);
      } catch (e) {
        print('Error uploading image $i: $e');
        // Continue with other images even if one fails
      }
    }
    
    return urls;
  }

  // Update report status (for admin)
  Future<bool> updateReportStatus(
    String reportId,
    ReportStatus status, {
    String? adminResponse,
    String? adminId,
  }) async {
    try {
      final success = await FirebaseService.updateReportStatus(
        reportId,
        status,
        adminResponse: adminResponse,
        adminId: adminId,
      );
      
      if (success) {
        _setError(null);
      } else {
        _setError('Failed to update report status');
      }
      
      return success;
    } catch (e) {
      _setError('Error updating report status: $e');
      return false;
    }
  }

  // Filter reports
  void filterReports({
    ReportStatus? status,
    Priority? priority,
    String? pondId,
  }) {
    // This would typically be handled by updating the Firebase stream
    // For now, we'll filter the existing list
    List<UserReport> filtered = List.from(_reports);
    
    if (status != null) {
      filtered = filtered.where((report) => report.status == status).toList();
    }
    
    if (priority != null) {
      filtered = filtered.where((report) => report.priority == priority).toList();
    }
    
    if (pondId != null) {
      filtered = filtered.where((report) => report.pondId == pondId).toList();
    }
    
    // For demo purposes, we'll just update the reports list
    // In production, you'd want to modify the Firebase query
    notifyListeners();
  }

  // Get reports by status
  List<UserReport> getReportsByStatus(ReportStatus status) {
    return _reports.where((report) => report.status == status).toList();
  }

  // Get reports by priority
  List<UserReport> getReportsByPriority(Priority priority) {
    return _reports.where((report) => report.priority == priority).toList();
  }

  // Get pending reports count
  int get pendingReportsCount {
    return _reports.where((report) => report.status == ReportStatus.pending).length;
  }

  // Get critical reports count
  int get criticalReportsCount {
    return _reports.where((report) => report.priority == Priority.critical).length;
  }

  // Search reports
  List<UserReport> searchReports(String query) {
    final lowerQuery = query.toLowerCase();
    return _reports.where((report) {
      return report.title.toLowerCase().contains(lowerQuery) ||
             report.description.toLowerCase().contains(lowerQuery) ||
             report.userName.toLowerCase().contains(lowerQuery);
    }).toList();
  }

  // Refresh reports
  Future<void> refreshReports() async {
    // The stream will automatically update, but we can trigger a manual refresh
    notifyListeners();
  }

  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String? error) {
    _errorMessage = error;
    if (error != null) {
      print('ReportsProvider Error: $error');
    }
    notifyListeners();
  }

  @override
  void dispose() {
    _reportsSubscription?.cancel();
    super.dispose();
  }
}